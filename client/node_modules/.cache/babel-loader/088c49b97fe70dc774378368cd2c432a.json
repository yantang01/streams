{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport isPromise from 'is-promise';\nimport { isSubmissionError } from './SubmissionError';\n\nvar mergeErrors = function mergeErrors(_ref) {\n  var asyncErrors = _ref.asyncErrors,\n      syncErrors = _ref.syncErrors;\n  return asyncErrors && typeof asyncErrors.merge === 'function' ? asyncErrors.merge(syncErrors).toJS() : _extends({}, asyncErrors, {}, syncErrors);\n};\n\nvar executeSubmit = function executeSubmit(submit, fields, props) {\n  var dispatch = props.dispatch,\n      submitAsSideEffect = props.submitAsSideEffect,\n      onSubmitFail = props.onSubmitFail,\n      onSubmitSuccess = props.onSubmitSuccess,\n      startSubmit = props.startSubmit,\n      stopSubmit = props.stopSubmit,\n      setSubmitFailed = props.setSubmitFailed,\n      setSubmitSucceeded = props.setSubmitSucceeded,\n      values = props.values;\n  var result;\n\n  try {\n    result = submit(values, dispatch, props);\n  } catch (submitError) {\n    var error = isSubmissionError(submitError) ? submitError.errors : undefined;\n    stopSubmit(error);\n    setSubmitFailed.apply(void 0, fields);\n\n    if (onSubmitFail) {\n      onSubmitFail(error, dispatch, submitError, props);\n    }\n\n    if (error || onSubmitFail) {\n      // if you've provided an onSubmitFail callback, don't re-throw the error\n      return error;\n    } else {\n      throw submitError;\n    }\n  }\n\n  if (submitAsSideEffect) {\n    if (result) {\n      dispatch(result);\n    }\n  } else {\n    if (isPromise(result)) {\n      startSubmit();\n      return result.then(function (submitResult) {\n        stopSubmit();\n        setSubmitSucceeded();\n\n        if (onSubmitSuccess) {\n          onSubmitSuccess(submitResult, dispatch, props);\n        }\n\n        return submitResult;\n      }, function (submitError) {\n        var error = isSubmissionError(submitError) ? submitError.errors : undefined;\n        stopSubmit(error);\n        setSubmitFailed.apply(void 0, fields);\n\n        if (onSubmitFail) {\n          onSubmitFail(error, dispatch, submitError, props);\n        }\n\n        if (error || onSubmitFail) {\n          // if you've provided an onSubmitFail callback, don't re-throw the error\n          return error;\n        } else {\n          throw submitError;\n        }\n      });\n    } else {\n      setSubmitSucceeded();\n\n      if (onSubmitSuccess) {\n        onSubmitSuccess(result, dispatch, props);\n      }\n    }\n  }\n\n  return result;\n};\n\nvar handleSubmit = function handleSubmit(submit, props, valid, asyncValidate, fields) {\n  var dispatch = props.dispatch,\n      onSubmitFail = props.onSubmitFail,\n      setSubmitFailed = props.setSubmitFailed,\n      syncErrors = props.syncErrors,\n      asyncErrors = props.asyncErrors,\n      touch = props.touch,\n      persistentSubmitErrors = props.persistentSubmitErrors;\n  touch.apply(void 0, fields);\n\n  if (valid || persistentSubmitErrors) {\n    var asyncValidateResult = asyncValidate && asyncValidate();\n\n    if (asyncValidateResult) {\n      return asyncValidateResult.then(function (asyncErrors) {\n        if (asyncErrors) {\n          throw asyncErrors;\n        }\n\n        return executeSubmit(submit, fields, props);\n      })[\"catch\"](function (asyncErrors) {\n        setSubmitFailed.apply(void 0, fields);\n\n        if (onSubmitFail) {\n          onSubmitFail(asyncErrors, dispatch, null, props);\n        }\n\n        return Promise.reject(asyncErrors);\n      });\n    } else {\n      return executeSubmit(submit, fields, props);\n    }\n  } else {\n    setSubmitFailed.apply(void 0, fields);\n    var errors = mergeErrors({\n      asyncErrors: asyncErrors,\n      syncErrors: syncErrors\n    });\n\n    if (onSubmitFail) {\n      onSubmitFail(errors, dispatch, null, props);\n    }\n\n    return errors;\n  }\n};\n\nexport default handleSubmit;","map":{"version":3,"names":["_extends","isPromise","isSubmissionError","mergeErrors","_ref","asyncErrors","syncErrors","merge","toJS","executeSubmit","submit","fields","props","dispatch","submitAsSideEffect","onSubmitFail","onSubmitSuccess","startSubmit","stopSubmit","setSubmitFailed","setSubmitSucceeded","values","result","submitError","error","errors","undefined","apply","then","submitResult","handleSubmit","valid","asyncValidate","touch","persistentSubmitErrors","asyncValidateResult","Promise","reject"],"sources":["/Users/ytang/Documents/React/streams/client/node_modules/redux-form/es/handleSubmit.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\nimport isPromise from 'is-promise';\nimport { isSubmissionError } from './SubmissionError';\n\nvar mergeErrors = function mergeErrors(_ref) {\n  var asyncErrors = _ref.asyncErrors,\n      syncErrors = _ref.syncErrors;\n  return asyncErrors && typeof asyncErrors.merge === 'function' ? asyncErrors.merge(syncErrors).toJS() : _extends({}, asyncErrors, {}, syncErrors);\n};\n\nvar executeSubmit = function executeSubmit(submit, fields, props) {\n  var dispatch = props.dispatch,\n      submitAsSideEffect = props.submitAsSideEffect,\n      onSubmitFail = props.onSubmitFail,\n      onSubmitSuccess = props.onSubmitSuccess,\n      startSubmit = props.startSubmit,\n      stopSubmit = props.stopSubmit,\n      setSubmitFailed = props.setSubmitFailed,\n      setSubmitSucceeded = props.setSubmitSucceeded,\n      values = props.values;\n  var result;\n\n  try {\n    result = submit(values, dispatch, props);\n  } catch (submitError) {\n    var error = isSubmissionError(submitError) ? submitError.errors : undefined;\n    stopSubmit(error);\n    setSubmitFailed.apply(void 0, fields);\n\n    if (onSubmitFail) {\n      onSubmitFail(error, dispatch, submitError, props);\n    }\n\n    if (error || onSubmitFail) {\n      // if you've provided an onSubmitFail callback, don't re-throw the error\n      return error;\n    } else {\n      throw submitError;\n    }\n  }\n\n  if (submitAsSideEffect) {\n    if (result) {\n      dispatch(result);\n    }\n  } else {\n    if (isPromise(result)) {\n      startSubmit();\n      return result.then(function (submitResult) {\n        stopSubmit();\n        setSubmitSucceeded();\n\n        if (onSubmitSuccess) {\n          onSubmitSuccess(submitResult, dispatch, props);\n        }\n\n        return submitResult;\n      }, function (submitError) {\n        var error = isSubmissionError(submitError) ? submitError.errors : undefined;\n        stopSubmit(error);\n        setSubmitFailed.apply(void 0, fields);\n\n        if (onSubmitFail) {\n          onSubmitFail(error, dispatch, submitError, props);\n        }\n\n        if (error || onSubmitFail) {\n          // if you've provided an onSubmitFail callback, don't re-throw the error\n          return error;\n        } else {\n          throw submitError;\n        }\n      });\n    } else {\n      setSubmitSucceeded();\n\n      if (onSubmitSuccess) {\n        onSubmitSuccess(result, dispatch, props);\n      }\n    }\n  }\n\n  return result;\n};\n\nvar handleSubmit = function handleSubmit(submit, props, valid, asyncValidate, fields) {\n  var dispatch = props.dispatch,\n      onSubmitFail = props.onSubmitFail,\n      setSubmitFailed = props.setSubmitFailed,\n      syncErrors = props.syncErrors,\n      asyncErrors = props.asyncErrors,\n      touch = props.touch,\n      persistentSubmitErrors = props.persistentSubmitErrors;\n  touch.apply(void 0, fields);\n\n  if (valid || persistentSubmitErrors) {\n    var asyncValidateResult = asyncValidate && asyncValidate();\n\n    if (asyncValidateResult) {\n      return asyncValidateResult.then(function (asyncErrors) {\n        if (asyncErrors) {\n          throw asyncErrors;\n        }\n\n        return executeSubmit(submit, fields, props);\n      })[\"catch\"](function (asyncErrors) {\n        setSubmitFailed.apply(void 0, fields);\n\n        if (onSubmitFail) {\n          onSubmitFail(asyncErrors, dispatch, null, props);\n        }\n\n        return Promise.reject(asyncErrors);\n      });\n    } else {\n      return executeSubmit(submit, fields, props);\n    }\n  } else {\n    setSubmitFailed.apply(void 0, fields);\n    var errors = mergeErrors({\n      asyncErrors: asyncErrors,\n      syncErrors: syncErrors\n    });\n\n    if (onSubmitFail) {\n      onSubmitFail(errors, dispatch, null, props);\n    }\n\n    return errors;\n  }\n};\n\nexport default handleSubmit;"],"mappings":"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"},"metadata":{},"sourceType":"module"}